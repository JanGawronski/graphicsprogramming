<!DOCTYPE html>
 <!-- It's the HTML5 standard. -->
 
 <html>
     <head>
         <title>Example 01 - triangle and square</title>
         <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
 
         <!-- The following meta line optimizes the site for mobile devices. 
		 It sets the viewport size to the screen size, so it will be displayed maximized, but unscaled. -->
         <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1">
         <style type="text/css">
             body {
                 /* Set the background color of the HTML page to black */
                 background-color: #ADEAEA;
 
                 /* Hide oversized content. This prevents the scroll bars. */
                 overflow: hidden;
             }
         </style>
         <!-- Include Three.js library -->
         <script src="three.js"></script>
		 <script src="Detector.js"></script>
     </head>
     <body>
         <!-- This is the DIV element which will contain the WebGL canvas. To be identifiable later on, the id 'WebGLCanvas' is applied to it. -->
         <div id="WebGLCanvas"> </div>
 
         <!-- This JavaScript block encloses the Three.js commands -->
        <script>
             // Global scene object
             var scene;
 
             // Global camera object
             var camera;
			 var choinkaMesh;
			 var pienMesh;
             // Initialize the scene
             initializeScene();
			 animateScene()
             /**
              * Initialize the scene.
              */
             function initializeScene(){
                 
               if(Detector.webgl){
                   renderer = new THREE.WebGLRenderer({antialias:true});

               // If its not supported, instantiate the canvas renderer to support all non WebGL
               // browsers
               } else {
                   renderer = new THREE.CanvasRenderer();
               }
                 // Set the background color of the renderer to black, with full opacity
                 renderer.setClearColor(0xADEAEA, 1);
 
                 // Get the size of the inner window (content area) to create a full size renderer
                 canvasWidth = window.innerWidth;
                 canvasHeight = window.innerHeight;
 
                 // Set the renderers size to the content areas size
                 renderer.setSize(canvasWidth, canvasHeight);
 
                 // Get the DIV element from the HTML document by its ID and append the renderers DOM
                 // object to it
                 document.getElementById("WebGLCanvas").appendChild(renderer.domElement);
 
                 // Create the scene, in which all objects are stored (e. g. camera, lights,
                 // geometries, ...)
                 scene = new THREE.Scene();
 
                 // Define camera and add it to the scene.
                 camera = new THREE.PerspectiveCamera(50, canvasWidth / canvasHeight, 1, 100);
                 camera.position.set(0, 0, 10);
                 camera.lookAt(scene.position);
                 scene.add(camera);
				 var koloGeometry = new THREE.CircleGeometry( 0, 100 );
				 var kolo2Geometry = new THREE.CircleGeometry( 0, 100 );
				 var koloMaterial = new THREE.MeshBasicMaterial({
                     color:0x000000,
                     side:THREE.DoubleSide
				 });
				 var kolo2Material = new THREE.MeshBasicMaterial({
                     color:0x000000,
                     side:THREE.DoubleSide
				 });
				 var koloMesh = new THREE.Mesh(koloGeometry, koloMaterial);
                 koloMesh.position.set(-9.0,-8.0,-20.0);
                 scene.add(koloMesh);
				 var kolo2Mesh = new THREE.Mesh(kolo2Geometry, kolo2Material);
                 kolo2Mesh.position.set(-13.0,-8.0,-20.0);
                 scene.add(kolo2Mesh);
                 // Create the triangle (or any arbitrary geometry).
                 var triangleGeometry = new THREE.Geometry();
                 triangleGeometry.vertices.push(new THREE.Vector3( 0.0,  0.5, 0.0));
                 triangleGeometry.vertices.push(new THREE.Vector3(-1.0, -0.5, 0.0));
                 triangleGeometry.vertices.push(new THREE.Vector3( 1.0, -0.5, 0.0));
                 triangleGeometry.faces.push(new THREE.Face3(0, 1, 2));
				 var choinkaGeometry = new THREE.Geometry();
                 choinkaGeometry.vertices.push(new THREE.Vector3( 0.0,  0.5, 0.0));
                 choinkaGeometry.vertices.push(new THREE.Vector3(-0.5, -0.5, 0.0));
                 choinkaGeometry.vertices.push(new THREE.Vector3( 0.5, -0.5, 0.0));
                 choinkaGeometry.faces.push(new THREE.Face3(0, 1, 2));
 
                 // To color the surface, a material has to be created.
                 // We use MeshBasicMaterial				 
                 // from which we need in this example only 'color'.
 
                 // Create a white basic material and activate the 'doubleSided' attribute to force the
                 // rendering of both sides of each face (front and back). This prevents the so called
                 // 'backface culling'. Usually, only the side is rendered, whose normal vector points
                 // towards the camera. The other side is not rendered (backface culling). But this
                 // performance optimization sometimes leads to wholes in the surface. When this happens
                 // in your surface, simply set 'doubleSided' to 'true'.
                 var triangleMaterial = new THREE.MeshBasicMaterial({
                     color:0x663300,
                     side:THREE.DoubleSide
					});
				 var choinkaMaterial = new THREE.MeshBasicMaterial({
                     color:0x66FF00,
                     side:THREE.DoubleSide
					});
 
                 // Create a mesh and insert the geometry and the material. Translate the whole mesh
                 // by -1.5 on the x axis and by 4 on the z axis. Finally add the mesh to the scene.
                 var triangleMesh = new THREE.Mesh(triangleGeometry, triangleMaterial);
                 triangleMesh.position.set(0.0, 1.0, 5.0);
                 scene.add(triangleMesh);
				 choinka1Mesh = new THREE.Mesh(choinkaGeometry, choinkaMaterial);
                 choinka1Mesh.position.set(1.65, 0.4, 5.0);
                 scene.add(choinka1Mesh);
				 choinka2Mesh = new THREE.Mesh(choinkaGeometry, choinkaMaterial);
                 choinka2Mesh.position.set(1.65,-0.1, 5.0);
                 scene.add(choinka2Mesh);
				 choinka3Mesh = new THREE.Mesh(choinkaGeometry, choinkaMaterial);
                 choinka3Mesh.position.set(1.65,-0.6, 5.0);
                 scene.add(choinka3Mesh);
				 
 
                 // The creation of the square is done in the same way as the triangle.
                 // 1. Instantiate the geometry object
                 // 2. Add the vertices
                 // 3. Define the faces by setting the vertices indices
                 var squareGeometry = new THREE.Geometry();
				 squareGeometry.vertices.push(new THREE.Vector3(-1.0,  1.0, 0.0));
                 squareGeometry.vertices.push(new THREE.Vector3( 1.0,  1.0, 0.0));
                 squareGeometry.vertices.push(new THREE.Vector3( 1.0, -1.0, 0.0));
                 squareGeometry.vertices.push(new THREE.Vector3(-1.0, -1.0, 0.0));
                 //squareGeometry.faces.push(new THREE.Face4(0, 1, 2, 3));         //No more Face4 in Three.js
				 squareGeometry.faces.push(new THREE.Face3(0, 1, 2));
				 squareGeometry.faces.push(new THREE.Face3(0, 2, 3));
				 
				 var pienGeometry = new THREE.Geometry();
				 pienGeometry.vertices.push(new THREE.Vector3(-0.1,  0.2, 0.0));
                 pienGeometry.vertices.push(new THREE.Vector3( 0.1,  0.2, 0.0));
                 pienGeometry.vertices.push(new THREE.Vector3( 0.1, -0.2, 0.0));
                 pienGeometry.vertices.push(new THREE.Vector3(-0.1, -0.2, 0.0));
                 //squareGeometry.faces.push(new THREE.Face4(0, 1, 2, 3));         //No more Face4 in Three.js
				 pienGeometry.faces.push(new THREE.Face3(0, 1, 2));
				 pienGeometry.faces.push(new THREE.Face3(0, 2, 3));
				 
				 var drzwiGeometry = new THREE.Geometry();
				 drzwiGeometry.vertices.push(new THREE.Vector3(-0.3,  0.4, 0.0));
                 drzwiGeometry.vertices.push(new THREE.Vector3( 0.3,  0.4, 0.0));
                 drzwiGeometry.vertices.push(new THREE.Vector3( 0.3, -0.4, 0.0));
                 drzwiGeometry.vertices.push(new THREE.Vector3(-0.3, -0.4, 0.0));
                 //squareGeometry.faces.push(new THREE.Face4(0, 1, 2, 3));         //No more Face4 in Three.js
				 drzwiGeometry.faces.push(new THREE.Face3(0, 1, 2));
				 drzwiGeometry.faces.push(new THREE.Face3(0, 2, 3));
				 
				 var oknoGeometry = new THREE.Geometry();
				 oknoGeometry.vertices.push(new THREE.Vector3(-0.3,  0.3, 0.0));
                 oknoGeometry.vertices.push(new THREE.Vector3( 0.3,  0.3, 0.0));
                 oknoGeometry.vertices.push(new THREE.Vector3( 0.3, -0.3, 0.0));
                 oknoGeometry.vertices.push(new THREE.Vector3(-0.3, -0.3, 0.0));
                 //squareGeometry.faces.push(new THREE.Face4(0, 1, 2, 3));         //No more Face4 in Three.js
				 oknoGeometry.faces.push(new THREE.Face3(0, 1, 2));
				 oknoGeometry.faces.push(new THREE.Face3(0, 2, 3));
				 
				 var kominGeometry = new THREE.Geometry();
				 kominGeometry.vertices.push(new THREE.Vector3(-0.1,  0.2, 0.0));
                 kominGeometry.vertices.push(new THREE.Vector3( 0.1,  0.2, 0.0));
                 kominGeometry.vertices.push(new THREE.Vector3( 0.1, -0.2, 0.0));
                 kominGeometry.vertices.push(new THREE.Vector3(-0.1, -0.2, 0.0));
                 //squareGeometry.faces.push(new THREE.Face4(0, 1, 2, 3));         //No more Face4 in Three.js
				 kominGeometry.faces.push(new THREE.Face3(0, 1, 2));
				 kominGeometry.faces.push(new THREE.Face3(0, 2, 3));
				 
				 var autoGeometry = new THREE.Geometry();
				 autoGeometry.vertices.push(new THREE.Vector3(-0.4,  0.0, 0.0));
                 autoGeometry.vertices.push(new THREE.Vector3( 0.4,  0.3, 0.0));
                 autoGeometry.vertices.push(new THREE.Vector3( 0.4, -0.2, 0.0));
                 autoGeometry.vertices.push(new THREE.Vector3(-0.4, -0.2, 0.0));
                 //squareGeometry.faces.push(new THREE.Face4(0, 1, 2, 3));         //No more Face4 in Three.js
				 autoGeometry.faces.push(new THREE.Face3(0, 1, 2));
				 autoGeometry.faces.push(new THREE.Face3(0, 2, 3));
				 
				 var auto2Geometry = new THREE.Geometry();
				 auto2Geometry.vertices.push(new THREE.Vector3(-0.5,  0.2, 0.0));
                 auto2Geometry.vertices.push(new THREE.Vector3( 0.5,  0.1, 0.0));
                 auto2Geometry.vertices.push(new THREE.Vector3( 0.5, -0.1, 0.0));
                 auto2Geometry.vertices.push(new THREE.Vector3(-0.5, -0.1, 0.0));
                 //squareGeometry.faces.push(new THREE.Face4(0, 1, 2, 3));         //No more Face4 in Three.js
				 auto2Geometry.faces.push(new THREE.Face3(0, 1, 2));
				 auto2Geometry.faces.push(new THREE.Face3(0, 2, 3));
                 // Create a white basic material and activate the 'Doubleside' attribute 
				 // (alternatives are: 'FrontSide' and 'BackSide')
                 var squareMaterial = new THREE.MeshBasicMaterial({
                     color:0x0D47A1,
                     side:THREE.DoubleSide
                 });
				 var pienMaterial = new THREE.MeshBasicMaterial({
                     color:0x663300,
                     side:THREE.DoubleSide
                 });
				 var drzwiMaterial = new THREE.MeshBasicMaterial({
                     color:0x000000,
                     side:THREE.DoubleSide
                 });
				 var oknoMaterial = new THREE.MeshBasicMaterial({
                     color:0xFFFFFF,
                     side:THREE.DoubleSide
				 });	
				 var kominMaterial = new THREE.MeshBasicMaterial({
                     color:0x000000,
                     side:THREE.DoubleSide
                 });
				 var autoMaterial = new THREE.MeshBasicMaterial({
                     color:0x000000,
                     side:THREE.DoubleSide
                 });
				 var auto2Material = new THREE.MeshBasicMaterial({
                     color:0x000000,
                     side:THREE.DoubleSide
                 });
 
                 // Create a mesh and insert the geometry and the material. Translate the whole mesh
                 // by 1.5 on the x axis and by 4 on the z axis and add the mesh to the scene.
                 var squareMesh = new THREE.Mesh(squareGeometry, squareMaterial);
                 squareMesh.position.set(0.0, -0.5, 5.0);
                 scene.add(squareMesh);
				 pienMesh = new THREE.Mesh(pienGeometry, pienMaterial);
                 pienMesh.position.set(1.65,-1.3, 5.0);
                 scene.add(pienMesh);
				 var drzwiMesh = new THREE.Mesh(drzwiGeometry, drzwiMaterial);
                 drzwiMesh.position.set(0.0,-1.1, 5.0);
                 scene.add(drzwiMesh);
				 var oknoMesh = new THREE.Mesh(oknoGeometry, oknoMaterial);
                 oknoMesh.position.set(0.5,-0.1, 5.0);
                 scene.add(oknoMesh);
				 var oknoMesh = new THREE.Mesh(oknoGeometry, oknoMaterial);
                 oknoMesh.position.set(-0.5,-0.1, 5.0);
                 scene.add(oknoMesh);
				 var kominMesh = new THREE.Mesh(kominGeometry, kominMaterial);
                 kominMesh.position.set(0.5,1.0, 4.9);
                 scene.add(kominMesh);
				 var autoMesh = new THREE.Mesh(autoGeometry, autoMaterial);
                 autoMesh.position.set(-1.83,-0.8, 5.0);
                 scene.add(autoMesh);
				 var auto2Mesh = new THREE.Mesh(auto2Geometry, auto2Material);
                 auto2Mesh.position.set(-1.83,-1.08, 5.0);
                 scene.add(auto2Mesh);
             }
            function animateScene(){
               // At first, we increase the y rotation of the triangle mesh and decrease the x
               // rotation of the square mesh.
           
               // Increase the y rotation of the triangle
               choinka1Mesh.rotation.y += 0.02;
			   choinka2Mesh.rotation.y += 0.02;
			   choinka3Mesh.rotation.y += 0.02;
			   pienMesh.rotation.y += 0.02;
               // Define the function, which is called by the browser supported timer loop. If the
               // browser tab is not visible, the animation is paused. So 'animateScene()' is called
               // in a browser controlled loop.
               requestAnimationFrame(animateScene);

               // Map the 3D scene down to the 2D screen (render the frame)
               renderScene();
           }
             /**
              * Render the scene. Map the 3D world to the 2D screen.
              */
             function renderScene(){
                 renderer.render(scene, camera);
             }
         </script>
     </body>
</html>