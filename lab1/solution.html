<!DOCTYPE html>
 <!-- It's the HTML5 standard. -->
 
 <html>
     <head>
         <title>Example 01 - triangle and square using Geometry class</title>
         <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
 
         <!-- The following meta line optimizes the site for mobile devices. 
		 It sets the viewport size to the screen size, so it will be displayed maximized, but unscaled. -->
         <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1">
         <style type="text/css">
             body {
                 /* Set the background color of the HTML page to black */
                 background-color: #000000;
 
                 /* Hide oversized content. This prevents the scroll bars. */
                 overflow: hidden;
             } 
         </style>
         <!-- Include Three.js library -->
         <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r124/three.js"></script>
         <script src="OrbitControls.js"></script>
		 <script src="stats.js"></script>
     </head>
	 
     <body>
         <!-- This is the DIV element which will contain the WebGL canvas. 
		 To be identifiable later on, 
		 the id 'WebGLCanvas' is applied to it. -->
         <div id="WebGLCanvas"> </div>
		 <div id="Stats-output"> </div>
 
         <!-- This JavaScript block encloses the Three.js commands -->
        <script>
            var stats = initStats();
            const scene = new THREE.Scene();
            let camera, ctr;
            init();
            animate();

            function addTriangle(position, vertices, color) {
                var triangleGeometry = new THREE.Geometry();
                triangleGeometry.vertices.push(new THREE.Vector3( vertices[0][0], vertices[0][1], vertices[0][2] ));
                triangleGeometry.vertices.push(new THREE.Vector3( vertices[1][0], vertices[1][1], vertices[1][2] ));
                triangleGeometry.vertices.push(new THREE.Vector3( vertices[2][0], vertices[2][1], vertices[2][2] ));
                triangleGeometry.faces.push(new THREE.Face3(2, 1, 0));

                var triangleMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    side:THREE.BackSide
                });

                var triangleMesh = new THREE.Mesh(triangleGeometry, triangleMaterial);
                triangleMesh.position.set(position[0], position[1], position[2]);
                scene.add(triangleMesh);
            }

            function addRectangle(position, a, b, color, onlyReturn) {
                var rectangleGeometry = new THREE.Geometry();
                rectangleGeometry.vertices.push(new THREE.Vector3( -a/2,  b/2, 0.0 ));
                rectangleGeometry.vertices.push(new THREE.Vector3(  a/2,  b/2, 0.0 ));
                rectangleGeometry.vertices.push(new THREE.Vector3(  a/2, -b/2, 0.0 ));
                rectangleGeometry.vertices.push(new THREE.Vector3( -a/2, -b/2, 0.0 ));
                rectangleGeometry.faces.push(new THREE.Face3(0, 1, 2));
                rectangleGeometry.faces.push(new THREE.Face3(0, 2, 3));

                var rectangleMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    side:THREE.BackSide
                });

                var rectangleMesh = new THREE.Mesh(rectangleGeometry, rectangleMaterial);
                rectangleMesh.position.set(position[0], position[1], position[2]);
                if (!onlyReturn)
                    scene.add(rectangleMesh);
                return rectangleMesh;
            }

            function addCircle(position, radius, color, onlyReturn) {
                var circleGeometry = new THREE.CircleGeometry( radius, 32 );

                var circleMaterial = new THREE.MeshBasicMaterial({ 
                    color: color,
                    side:THREE.DoubleSide 
                });

                var circleMesh = new THREE.Mesh(circleGeometry, circleMaterial);
                circleMesh.position.set(position[0], position[1], position[2]);
                if (!onlyReturn)
                    scene.add(circleMesh);
                return circleMesh;
            }

            function addChristmasTree(position) {
                for (let i = 0; i < 3; i++) { // three green triangles
                    addTriangle([position[0], position[1] - 0.4 * i + 2, position[2]], [
                        [0.0, (0.08*i + 0.3), 0.0],
                        [-(0.08*i + 0.4), -(0.08*i + 0.4), 0.0],
                        [(0.08*i + 0.4), -(0.08*i + 0.4) , 0.0]
                    ],
                    "green"
                    );
                }
                addRectangle([position[0], position[1] + 0.49, position[2]], .2, .3, "#964B00"); // brown trunk
            }

            function addHouse(position) {
                addRectangle([position[0], position[1], position[2]], 2.0, 2.0, "yellow"); // walls
                addTriangle([position[0], position[1] + 1.0, position[2]], [ // roof
                    [0.0, 1.0, 0.0],
                    [-1.0, 0.0, 0.0],
                    [1.0, 0.0, 0.0]
                ],
                "red"
                );
                addRectangle([position[0], position[1] - 0.55, position[2]], 0.6, 0.9, "brown"); // door
                addRectangle([position[0] - 0.5, position[1] + 0.3, position[2] + 0.01], 0.5, 0.5, "blue"); // window
                addRectangle([position[0] + 0.5, position[1] + 0.3, position[2] + 0.01], 0.5, 0.5, "blue"); // window
            }

            function addCar(position) {
                const group = new THREE.Group();
                group.add(addRectangle([0,0.25, 0], 1.5, 0.5, "blue", true)); // upper body
                group.add(addRectangle([0, -0.25, 0], 2.0, 0.5, "blue", true)); // lower body
                group.add(addCircle([-0.6, -0.6, 0.01], 0.25, "black", true)); // left wheel
                group.add(addCircle([0.6, -0.6, 0.01], 0.25, "black", true)); // right wheel

                group.position.set(position[0], position[1], position[2]);
                scene.add(group);
                return group;
            }


            function init() {
                renderer = new THREE.WebGLRenderer({antialias:true});
                renderer.setClearColor(0x069af0, 1);

                canvasWidth = window.innerWidth;
                canvasHeight = window.innerHeight;
                renderer.setSize(canvasWidth, canvasHeight);

                document.getElementById("WebGLCanvas").appendChild(renderer.domElement);

                camera = new THREE.PerspectiveCamera(45, canvasWidth / canvasHeight, 1, 100);
                camera.position.set(0, 0, 10);
                camera.lookAt(scene.position);
                scene.add(camera);
            
                addChristmasTree([-0.5, -1.5, 4.0]);
                addHouse([2.0, 0.0, 4.0]);
                car = addCar([-3.0, -1.0, 4.0]);

                addRectangle([0.0, -3.0, 0], 20, 3, "gray"); // ground

                clock = new THREE.Clock();
            }

            function renderScene(){
                renderer.render(scene, camera);
            }
            
            function animate(){
                requestAnimationFrame(animate);
                stats.update();
                if (car) {
                    car.position.x += clock.getDelta();;
                    if (car.position.x > 6) car.position.x = -6;
                }
                renderScene();
            }
            
            function initStats() {
                var stats = new Stats();
                stats.setMode(0);
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.left = '0px';
                stats.domElement.style.top = '0px';
                document.getElementById("Stats-output").appendChild(stats.domElement);
                return stats;
            }
         </script>
     </body>
</html>